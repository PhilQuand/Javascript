<!DOCTYPE html>
<html>
<head>
    <title>IRE 2018 template: Google Sheets to interactive table</title>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <script src="https://code.jquery.com/jquery-3.5.1.min.js"></script>
<!-- contruction d'une table jquery -->
    <link rel="stylesheet" href="https://cdn.datatables.net/1.10.22/css/jquery.dataTables.min.css" />
    <script src="https://cdn.datatables.net/1.10.22/js/jquery.dataTables.min.js"></script>

<!-- Chargement des données venant d'une Google Sheet -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tabletop.js/1.5.1/tabletop.min.js"></script>

<!-- multi selection sur les colonnes de la table d'après https://github.com/vedmack/yadcf -->
  <link href="https://cdnjs.cloudflare.com/ajax/libs/yadcf/0.9.4/jquery.dataTables.yadcf.css" rel="stylesheet" type="text/css" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/yadcf/0.9.4/jquery.dataTables.yadcf.js" integrity="sha512-stJr1VNN+I0yBoLYTHGUgHIeK8eibAXMzWdZn7SC8vO5FtzzWvQFPMaEWWSpOsnSrJ75GjKjOuJaJoghT3/8bw==" crossorigin="anonymous"></script>

<!-- ressources communes à tous les blogs... -->
  <link href="https://philquand.github.io/Javascript/Blog-widgets/All-Blogs-Style.css" rel="stylesheet" type="text/css" />
  <script src='https://philquand.github.io/Javascript/Blog-widgets/All-Blogs-Scripts.js'></script>

<!-- Load Leaflet -->
  <link crossorigin='' href='https://unpkg.com/leaflet@1.4.0/dist/leaflet.css' integrity='sha512-puBpdR0798OZvTTbP4A8Ix/l+A4dHDD0DGqYW6RQ+9jxkRFclaxxQb/SJAWZfWAkuyeQUytO7+7N4QKrDh+drA==' rel='stylesheet'/>
  <script crossorigin='' integrity='sha512-QVftwZFqvtRNi0ZyCtsznlKSWOStnDORoefr1enyq5mVL4tmKB3S/EnC3rRJcxCPavG10IcrVGSmPh6Qw5lwrg==' src='https://unpkg.com/leaflet@1.4.0/dist/leaflet.js'></script>
<!-- Load Esri Leaflet from CDN -->
  <script src="https://unpkg.com/esri-leaflet@2.3.0/dist/esri-leaflet.js"
  integrity="sha512-1tScwpjXwwnm6tTva0l0/ZgM3rYNbdyMj5q6RSQMbNX6EUMhYDE3pMRGZaT41zHEvLoWEK7qFEJmZDOoDMU7/Q=="
  crossorigin=""></script>
  <!-- Load Esri Leaflet Geocoder from CDN -->
  <link rel="stylesheet" href="https://unpkg.com/esri-leaflet-geocoder@2.2.14/dist/esri-leaflet-geocoder.css"
    integrity="sha512-v5YmWLm8KqAAmg5808pETiccEohtt8rPVMGQ1jA6jqkWVydV5Cuz3nJ9fQ7ittSxvuqsvI9RSGfVoKPaAJZ/AQ=="
    crossorigin="">
  <script src="https://unpkg.com/esri-leaflet-geocoder@2.2.14/dist/esri-leaflet-geocoder.js"
    integrity="sha512-uK5jVwR81KVTGe8KpJa1QIN4n60TsSV8+DPbL5wWlYQvb0/nYNgSOg9dZG6ViQhwx/gaMszuWllTemL+K+IXjg=="
    crossorigin=""></script>
<!--Load markerclusters -->
  <link href='https://philquand.github.io/Javascript/LeafLet/MarkerCluster/MarkerCluster.css' rel='stylesheet' type='text/css'/>
  <link href='https://philquand.github.io/Javascript/LeafLet/MarkerCluster/MarkerCluster.Default.css' rel='stylesheet' type='text/css'/>
  <script src="https://philquand.github.io/Javascript/LeafLet/MarkerCluster/leaflet.markercluster-src.js" type='text/javascript'></script>
  <script src="https://unpkg.com/leaflet.markercluster.freezable@1.0.0/dist/leaflet.markercluster.freezable.js" type='text/javascript'></script>

<!--Load carte-infos-semaines -->
  <link href='https://philquand.github.io/Javascript/Blog-widgets/Collectif Santé 37/Coordination Lettres Infos Semaine 2021/carte-infos-semaines.css' rel='stylesheet' type='text/css'/>
<!-- Full screen plugin -->
  <script src='https://api.mapbox.com/mapbox.js/plugins/leaflet-fullscreen/v1.0.1/Leaflet.fullscreen.min.js'></script>
  <link href='https://api.mapbox.com/mapbox.js/plugins/leaflet-fullscreen/v1.0.1/leaflet.fullscreen.css' rel='stylesheet' />
<!-- accés au Geoportail -->
  <!--script data-key="f5cse26aiqvu6j4xqtngh5zh" src='http://ignf.github.io/geoportal-extensions/leaflet-latest/dist/GpPluginLeaflet.js'></script-->
  <script src='http://ignf.github.io/geoportal-extensions/leaflet-latest/dist/GpPluginLeaflet.js'></script>
  <link href='http://ignf.github.io/geoportal-extensions/leaflet-latest/dist/GpPluginLeaflet.css' rel='stylesheet' />
  <script src='http://ignf.github.io/geoportal-extensions/leaflet-latest/dist/GpPluginLeaflet-src.js'></script>
  <link href='http://ignf.github.io/geoportal-extensions/leaflet-latest/dist/GpPluginLeaflet-src.css' rel='stylesheet' />
</head>
<body>
<div class="SIURFFMR right" >
<span class="divImg">
<a href="https://1.bp.blogspot.com/-5one8y9NJ90/YBXHCXEmcoI/AAAAAAAAoDI/3MZAUOI27Rc93YhvkIFa1vImvOBcP4DTACLcBGAsYHQ/s0/reforme-hopital-public.jpg" style="display: block; padding: 1em 0; text-align: center; ">
<img alt="" border="0" data-original-height="374" data-original-width="497" src="https://1.bp.blogspot.com/-5one8y9NJ90/YBXHCXEmcoI/AAAAAAAAoDI/3MZAUOI27Rc93YhvkIFa1vImvOBcP4DTACLcBGAsYHQ/s0/reforme-hopital-public.jpg"/></a>
</span>
<span class="divText">
<p><strong>Suppressions - Destructions - Réductions d'hôpitaux et de services, surtout publics</strong></p>
<p>Première publication juin 2009 - Mise à jour 02/12/2021</p>
<p><strong>ATTENTION - Données fournies par nos comités et contacts. </strong></p>
<p><strong>Nous attendons vos compléments ou modifications, des erreurs et oublis sont évidemment possibles, merci à toutes et tous</strong></p>
<div style="display:none">
<ul>
<li><strong>Établissements de santé</strong> entre 2007 et 2008 (DGOS) : <br />- public : perte de 8 Centres hospitaliers (519 à 511) et 9 hôpitaux locaux (343 à 334)<br />- privé lucratif : perte de 8 établissements (1055 à 1047)<br />- privé non lucratif : perte de 38 établissements (792 à 754)</li>
</ul>
<p>Pour la Direction de la recherche, des études, de l'évaluation et des statistiques du ministère de la Santé (Drees), en 2018, quelques indices : "Sous l'effet des réorganisations et des restructurations, le nombre d'entités géographiques de statut public ou privé a continué de reculer en 2017." L'évolution est "plus marquée" pour les hôpitaux : 1.363 en 2017 contre 1.458 sites en 2013 (-7%). Significative pour les établissements privés à but non lucratif : 680 en 2017 contre 712 sites en 2013 (-4%). Moins importante pour les cliniques à but lucratif : 1.001 en 2017 contre 1.022 entités en 2013 (-2%)".</p>
<ul>
<li><strong>Chirurgie</strong> : suppressions de 299 services sur 568 restructurations entre 1997 &amp; 2008 (DGOS)</li>
<li><strong>CIVG</strong> : Entre 2000-2006 : pertes de 90 CIVG</li>
<li><strong>Maternités</strong> : Depuis 1975 pour les maternités chute de 60% : de 1379 à 584 début 2008 ; 519 en début 2016 ; environ 500 au début 2018.<br />Pour d'autres sources (DRESS) : passage de 1747 maternités en 1972 - 1128 en 1981 - 535 en 2010 soit chute de 69% !<br />Entre 2003 et 2010, le nombre de maternités est passé de 618 à 535 (Blondel et al 2005), 14 fermetures en moyenne/an contre 28 entre 1998 et 2003<br />Entre 1997 et 2008, fermeture de 196 services <strong>d'obstétriques</strong> sur 568 restructurations (DGOS).</li>
</ul>
<p>DRESS : pour les maternités, le bilan 2018 des établissements de santé objective leur raréfaction : 1 369 en 1975, 814 en 1996, 498 en 2016 (une division par deux en vingt ans !). Et celle du nombre de lits d'obstétrique, "quasiment divisé par deux depuis trente ans", alors que la natalité "est restée dynamique au cours de toute la période, avec 710 000 à 800 000 naissances par an".</p>
<ul>
<li><strong>Maternités 2</strong> : <em><u>Rapport IGAS</u></em> 2012 - «<em>Le nombre de maternités est passé de 1 369 en 1975 à 1 010 en 1985, 814 en 1996, 779 en 1997, 576 en 2007, 554 en 2008, soit une baisse pratiquement linéaire pendant 30 ans, alors même que le nombre de naissances ré-augmentait. Parallèlement le nombre de lits d’obstétrique a été divisé par deux. Le taux d’utilisation des lits de maternité a donc fortement augmenté, passant de 22 accouchements /lit/an en 1975 à 46/lits/an fin 2008. Selon l’étude NFT/DEXIA, près de 180 opérations de recomposition ont eu lieu en obstétrique entre 1995 et 2005. Elles se sont soldées par 126 fermetures de services de maternité et par une quarantaine de regroupements</em>».</li>
<li><strong>Maternités 3 </strong>: essor des <strong>accouchements extrahospitaliers</strong> non programmés : 6 733 sont identifiés entre 2012-2014 soit 3 pour 1 000 accouchements (APMnews, 15 mars 2019). Du fait des concentrations de maternités, il n'y a plus que <strong>28% des accouchements en 2016 qui ont lieu dans la ville de résidence de la mère</strong>. (<a href="https://www.insee.fr/fr/statistiques/3047024">https://www.insee.fr/fr/statistiques/3047024</a>).</li>
<li><strong>Pharmacies </strong>: environ 22 000 en début 2018 -prévision de 10 000 fermetures (Cour des Comptes septembre 2017).</li>
<li><strong>Lits </strong>: multiples fermetures et pourtant maintien apparent de la France en bonne position ?</li>
</ul>
<p>- Le maximum de lits est atteint en 1980, la baisse ne s'est jamais arrêtée depuis, soit près de 5 000 lits supprimés par an en moyenne sur les 30 dernières années</p>
<p>1980 : 11.1 Lits /1000 hab, pour 55 254 000 habitants</p>
<p>2013 : 6.5 lits/ 1000 hab, pour 65 564 000 habitants</p>
<p>- Fermeture massive de 83 000 lits de médecine, de chirurgie et d’obstétrique dans les établissements publics et privés entre 1992 et 2003.</p>
<p>- <strong>Les lits de longue durée</strong> (USLD) se sont effondrés passant de 80 000 en 2003 à 32 000 en 2011 (soit moins 40%), avec donc transfert vers les lits médicalisés de EHPAD. Leur baisse commence vers 2001-2002<br />Cf. <a href="https://www.irdes.fr/EspaceEnseignement/ChiffresGraphiques/Cadrage/Hopital/Lits.htm">https://www.irdes.fr/EspaceEnseignement/ChiffresGraphiques/Cadrage/Hopital/Lits.htm</a></p>
<p>- selon <em>Le casse du siècle</em>, entre 2003 et 2016, 13% des lits d'hospitalisation complète ont été supprimés (64 000 au total) mais, à contrario, le nombre de "lits" d'hospitalisation de moins de 24 heures a progressé dans le même temps de 49 000 à 75 000 (+ 53%).</p>
<p>- D‘après les chiffres de la DREES le secteur public en total de lits entre 2003 et 2016 aurait perdu 52 863 lits : <br /><a href="https://drees.solidarites-sante.gouv.fr/IMG/pdf/pano-etab-sante-2016.pdf">https://drees.solidarites-sante.gouv.fr/IMG/pdf/pano-etab-sante-2016.pdf</a></p>
<p><a href="https://drees.solidarites-sante.gouv.fr/IMG/xlsx/es2018_fiche_01_categorie_es_v5.xlsx">https://drees.solidarites-sante.gouv.fr/IMG/xlsx/es2018_fiche_01_categorie_es_v5.xlsx</a></p>
<p><a href="https://drees.solidarites-sante.gouv.fr/IMG/pdf/es2003.pdf">https://drees.solidarites-sante.gouv.fr/IMG/pdf/es2003.pdf</a><br /><br /></p>
<table>
<tbody>
<tr>
<td width="528">
<p><strong>Offre de lits en 2016</strong> :</p>
<p> -total de 404 248</p>
<p>-Public 250 104</p>
<p>-privé non lucratif 56 994</p>
<p>-Lucratif 97 150</p>
<p>-Dont MCO ?</p>
</td>
<td width="528">
<p><strong>Offre de lits en 2003</strong> :</p>
<p>-total de 457 111</p>
<p>-Public 299 102</p>
<p>-Privé lucratif et non lucratif 158 009</p>
<p>-Dont aigus ?</p>
</td>
</tr>
</tbody>
</table>
<p>- Selon le rapport de novembre 2017 de l'OCDE la France serait au 11° r en 2015 pour le nombre de lits par habitants alors qu'elle était au 6° en 2000. Selon ce rapport en 15 ans, le nombre de lits aurait baissé de 15 % à l'hôpital, alors que la population a augmenté de 10 %. "Tous les types de lits sont concernés par cette baisse", développent les auteurs du rapport, notamment en service de psychiatrie (-8 %), de soins aigus (-12,5 %) mais surtout en ce qui concerne les soins de longue durée (-60 %).</p>
<ul>
<li><strong>Urgences </strong>: transformation accélérée des urgences en Centres d'Accueil de soins non programmés, moyen de les fermer la nuit et de les priver d'urgentistes<strong>.</strong></li>
</ul>
<p>Entre 1995 et 2016, 95 services d'urgences publics ou privés non lucratifs ont été fermés.</p>
<p><strong>Contact pour mises à jour et modifications : <a href="mailto:Michel.Antony@wanadoo.fr">Michel.Antony@wanadoo.fr</a></strong></p>
</div>
</span></div>
<style>
.SIURFFMR {
    display: flex; 
    align-items: center;
    width: 100%; 
    padding: 1em;
}
.SIURFFMR .divImg {
    max-width: 450px; 
    width: 30%; 
    /*margin-bottom: 1em;*/
}
.SIURFFMR.left .divImg {
    margin-right: 0.5em;
}
.SIURFFMR.right {
    flex-direction: row-reverse;
}
.SIURFFMR.right .divImg {
    margin-left: 0.5em;
}
.SIURFFMR .divText {
    width: 100%; 
}
.SIURFFMR .divImg img {
    width: 100%;
}
@media (max-width: 1100px) {
    .SIURFFMR {
        display: block; 
    }
    .SIURFFMR .divImg img {
        display: block;
        margin-left: auto;
        margin-right: auto;
        width: 80%; 
    }
    .SIURFFMR .divText, .SIURFFMR .divImg {
        width: 100%; 
    }
}
</style>
<div id="DATA">
    <div id="exportDATA">
    <div id="exportCOMMUNE" style="display:none"></div>    
    <div id="exportINSEE" style="display:none"></div>    
  </div>
</div>
<div id="Fermetures"></div>
</body>
</html>
<style>
.popBody {
  width: 100%;
  max-width: 100%;
  text-align: center;
}
.popItem {
  margin-top: 1em;
}
.popLieux {
  width: 100%;
  max-width: 100%;
  background-color: #00b0f0;
  text-align: center;
  font-size: 125%;
}
.popTitle {
  font-style: italic;
  font-weight: bold;
}
.popNum {
  /*font-style: italic;*/
  font-weight: bold;
  font-size: 150%;
}
.popNote {
  font-style: italic;
  /*font-weight: bold;*/
}
#table_wrapper {
  display: none;
}
/*button#btData.styled {
  clear: both !important;
  display: block;
  margin-left: auto;
  margin-right: auto;
};*/
</style>
<script>
(function($) {
$.fn.mapAllBlogs = function(optionsPlugIn) {
  var loading = $('<div id="loading"/>');
  loading.append('<p>Chargement ...</p>');
  $(this).append(loading);


  var infoMapWrapper = $('<div id="infoMap-wrapper"><div id="infoMap" class="dispInfoMap"></div></div>');
  $(this).append(infoMapWrapper);

  var dataTable = $('<table id="table" class="table table-striped table-bordered" />');
  $(this).append(dataTable);

  var iconMarkersBuilder, legendTitle, objectOverlays;

  var optionsData = readUrlParam('options');
  if (typeof optionsData !== 'undefined') {
    loadFromJS(optionsData,
      () => {
        runMapandTable(options);
      },
      (optionsData) => {
        loading.html(optionsData + " :<br>ne semble pas être l'adresse d'un fichier accessible");
      }
    );
  }
  else runMapandTable(optionsPlugIn);

  function runMapandTable(options) {

    if (typeof options == 'undefined' ) var options = {};
    if (typeof options.popupData == 'undefined' ) options.popupData = {};
    

    if (typeof options['legend'] == 'undefined') {
      legendTitle = '';
      iconMarkersBuilder = data => {
        for (var i = 0; i < data.length; i++) {
          data[i].iconMarker = 0;
        }
        return [{
        icon: {leaflet: new L.Icon({
          iconUrl: 'https://philquand.github.io/Javascript/LeafLet/Leaflet-color-markers/img/marker-icon-2x-blue.png',
          shadowUrl: 'https://philquand.github.io/Javascript/LeafLet/Leaflet-color-markers/img/marker-shadow.png',
          iconSize: [13, 20],
          iconAnchor: [6, 20],
          popupAnchor: [1, -17],
          shadowSize: [20, 20]
        })},
        title: 'établissements'        
      }];
      }
    }
    else {
      if (typeof options['legend'].title !== 'undefined') legendTitle = options['legend'].title;
      else legendTitle = '';
      iconMarkersBuilder = data => {
        for (var i = 0; i < data.length; i++) {
          data[i].iconMarker = options['legend']['affect'](data[i]);
        }
        return options.legend.icons;
      }
    }
    
    objectOverlays = {};
     if (typeof options.controlLayers === 'undefined' || typeof options.controlLayers.controlOverlays === 'undefined' ) {
      objectOverlays["overlayTitle"] = 'Autres';
      objectOverlays["controlOverlays"] = {"Autres" : new L.layerGroup()};
      objectOverlays["overlays"] = [{isInGroup: data => {return true;}, title: 'Autres', isVisible: true }];
    }
    else {
      if (typeof options.controlLayers.controlOverlays.title !== 'undefined') objectOverlays["overlayTitle"] = options.controlLayers.controlOverlays.title;
      else objectOverlays["overlayTitle"] = '';
      objectOverlays["controlOverlays"] = {};
      objectOverlays["overlays"] = [];
      for (var i = 0; i < options.controlLayers.controlOverlays.overlays.length; i++) {
        objectOverlays["controlOverlays"][options.controlLayers.controlOverlays.overlays[i].title] = new L.layerGroup();
        objectOverlays["overlays"].push({
          isInGroup: options.controlLayers.controlOverlays.overlays[i].isInGroup,
          title: options.controlLayers.controlOverlays.overlays[i].title,
          isVisible: true,
        });
      }
    }


    var storedData = readUrlParam('data');
    if (typeof storedData === 'undefined') {
      if (typeof options.data === 'string') var storedData = options.data;
      else if (typeof options.data === 'object' && typeof options.data.base === 'string') var storedData = options.data.base;
    };
    if (typeof storedData !== 'undefined') {
      if (typeof storedData === 'string') {
        if(storedData.startsWith('https://docs.google.com/spreadsheets')) {
          loadDataFromGoogle(storedData);
        }
        else if (storedData.endsWith(".json") || storedData.endsWith(".geojson")) {
          loadFromJSON(storedData,
            (procData) => {
              var isGeoJSON = (file) => {
                if (file.type == "FeatureCollection" && file.features[0].hasOwnProperty('geometry') && file.features[0]['geometry'] != null) return true;
                else return false;
              }
              var data = getDataFromJSON(procData);
              if (typeof data !== 'undefined') {
                if (typeof options.data.dataTransformer === 'function') {
                  options.data.dataTransformer(data, geolocData)
                }
                else if (typeof options.data.dataTransformer !== 'undefined' || !isGeoJSON(procData)) {
                  geolocData(data);
                }
                else {
                  runData(data);
                }
              };
            },
            (err) => {
              loading.html(err.message);
            }
          );
        }
        else if (storedData.endsWith(".js")) {
          loadFromJS(storedData,
            (procData) => {
              if (typeof this['data'] !== 'undefined') {
                geolocData(this['data']);
              }
            },
            (err) => {
              loading.html(err.message);
            }
          );
        }
      }
    }
    else if ($('#dataStore').length == 1) {
      storedData = $('#dataStore').html();
      storedData = JSON.parse(storedData);
      storedData = getDataFromJSON(storedData);
      //if (typeof checkIfStoreNeedsUpdate !== 'undefined' && checkIfStoreNeedsUpdate) loadData(options.data);
      //else runData(storedData);
      runData(storedData);
    }
    
    function getDataFromJSON(storedData) {
      if (jQuery.isArray(storedData)) {
        //fichier au format interne
        console.log("fichier de données au format interne.")
        return storedData
      }
      else {
        try {
          //fichier au format GeoJson
          //throw "trying to read file as GeoJSON : erreur n°0";
          if (storedData.type != "FeatureCollection") throw "trying to read file as GeoJSON : erreur n°1";
          if (!jQuery.isArray(storedData.features)) throw "trying to read file as GeoJSON : erreur n°2";
          var data = [];
          var features = storedData.features;
          for (var i = 0; i < features.length; i++) {
            var newItem = {};
            if (features[i]["geometry"] != null) {
              newItem["lng"] = features[i]["geometry"]["coordinates"][0];
              newItem["lat"] = features[i]["geometry"]["coordinates"][1];
            };
            var properties = features[i]["properties"];
            for (var prop in properties) {
              newItem[prop] = properties[prop];
            }
            data.push(newItem);
          }
          console.log("fichier de données au format GeoJSON.")
          return data;
        }
        catch (err) { //We can also throw from try block and catch it here
          console.log(err);
          var data = options.data;
          if (typeof data === 'object') data = options.data.base;
          loading.html(data + " :<br>n'est pas un fichier de données d'un format reconnu");
        }
        finally {
          //code for finally block
        }
      }
    };

    function loadDataFromGoogle(dataFromGoogle) {
      // Table des Fermetures
      //var SHEET_ID = 'https://docs.google.com/spreadsheets/d/1XBQe8JiZ5cepr-s_TBjBqQcaBx4Y83SQS4PaNoXnNjM/edit?usp=sharing';
      // Table de test (10 lignes)
      //var SHEET_ID = 'https://docs.google.com/spreadsheets/d/1PbgwjD-HodM0JdnlRtQvmTlagE3CzBExjfpCua6-dh4/edit?usp=sharing';

      Tabletop.init({
        key: dataFromGoogle,
        callback: geolocData,
        simpleSheet: true
      });
    };

    function geolocData(data) {
          if (typeof options.data === 'object' && typeof options.data.INSEE_KEY !== 'undefined') geolocDataWithINSEE(data);
          else geolocDataWithoutINSEE(data);
 
      function geolocDataWithoutINSEE(data) {
        var indexCal = 0;
        var indexRes = 0;
        var indexEnd = data.length;

        if (indexEnd < data.length) {
          data.splice(indexEnd, data.length - 1)
        }
        else if (indexEnd > data.length) indexEnd = data.length;

        var makeLocation = function(iData, iVar) {
          if (typeof options.data === 'object' && typeof options.data.geolocData !== 'undefined') {
            return options.data.geolocData(iData, iVar);
          }
          else {
            if (typeof options.data === 'string') var storedData = options.data;
            else if (typeof options.data === 'object' && typeof options.data.base === 'string') var storedData = options.data.base;
            else var storedData = 'options.data';
            loading.html(storedData + "<br>contient des objets qui ont besoin d'être géolocalisés<br>mais la fonction de géolocalisation options.data.geolocData n'est pas définie...");
            return false;
          }
        };

        add2Layer(indexCal);

        function add2Layer(indexLoc) {
          indexCal++;
          var lieux = makeLocation(data, indexLoc);
          if (!isValidCoord(data[indexLoc].lat, data[indexLoc].lng)) {
            L.esri.Geocoding.geocode({
                requestParams: {
                  maxLocations: 1
                }
              })
              .text(lieux)
              .run(function(error, results, response) {
                var _this = this
                if (error) {
                  if (typeof options.geolocError === 'function') options.geolocError(error, data[indexLoc])
                  else {
                    console.log(error);
                    console.log(lieux);
                  };
                  //return;
                }
                else {
                  //if (!error && typeof results.results !== 'undefined') {
                  if (!error && results.results.length > 0) {
                    indexRes++;
                    data[indexLoc].lat = results.results[0].latlng.lat;
                    data[indexLoc].lng = results.results[0].latlng.lng;
                  }
                  else {
                    if (typeof options.geolocError === 'function') options.geolocError("Problème d'accés au résultat de géolocalisation :", data[indexLoc])
                    else {
                      console.log(error);
                      console.log(lieux);
                    };
                  }
                }
                checkIfEnd(indexCal, indexEnd, add2Layer);
              });
          }
          else checkIfEnd(indexCal, indexEnd, add2Layer);

        }
      };

      function geolocDataWithINSEE(data) {
        var villesINSEE = 'https://philquand.github.io/Javascript/LeafLet/json/cities.json'
        Promise.all([
          // chargement du code INSEE des villes
          // d'après https://www.data.gouv.fr/fr/datasets/regions-departements-villes-et-villages-de-france-et-doutre-mer/
          load.json(villesINSEE),
        ]).then(
          function(values) {
            console.log('Everything has been loaded!');
            villesINSEE = loadVal(values, villesINSEE)
            //villesINSEE = values[0]['val'];
            //var output = [];
            var indexCal = 0;
            var indexRes = 0;
            var indexEnd = data.length;
            var INSEE_key = options.data.INSEE_KEY;
            //var indexEnd = 10;

            if (indexEnd < data.length) {
              data.splice(indexEnd, data.length - 1)
            }
            else if (indexEnd > data.length) indexEnd = data.length;

            /*if (storedData !== '') {
              var storedDataHasChanged = checkStoredData();
              if (storedDataHasChanged) loading.find('p').html('storedData et data sont différents');
              else loading.find('p').html('storedData et data sont identiques');
              return;
            }
            function checkStoredData() {
              if (storedData !== '') {
                if (data.length !== storedData.length) {
                  console.log('storedData and data have different length')
                  return true;
                }
                var dataJSON = $('<div></div>')
                dataJSON.html(JSON.stringify(data));
                dataJSON = JSON.parse(dataJSON.html());
                for (var i = 0; i < data.length; i++) {
                  delete storedData[i].iconMarker;
                  delete storedData[i].lat;
                  delete storedData[i].lng;
                  if (!deepEqual(storedData[i], dataJSON[i])) {
                    console.log('storedData and data are different on (at least) rank ' + eval(i + 2))
                    return true;
                  }
                }
                return false;
              }
              else return false;
            }*/

            var makeLocation = function(iData, iVar) {
              if (typeof options.data === 'object' && typeof options.data.geolocData !== 'undefined') {
                return options.data.geolocData(iData, iVar);
              }
              else {
                if (typeof options.data === 'string') var storedData = options.data;
                else if (typeof options.data === 'object' && typeof options.data.base === 'string') var storedData = options.data.base;
                else var storedData = 'options.data';
                loading.html(storedData + "<br>contient des objets qui ont besoin d'être géolocalisés<br>mais la fonction de géolocalisation options.data.geolocData n'est pas définie...");
                return false;
              }
            };
            var allreadyGeoLoc = checkAllreadyGeoLoc();
            if (!allreadyGeoLoc) return false

            function checkAllreadyGeoLoc() {
              var allreadyGeoLoc = {};
              for (var i = 0; i < data.length; i++) {
                if (!isValidCoord(data[i].lat, data[i].lng)) {
                  var lieux = makeLocation(data, i);
                  if (typeof lieux !== 'undefined') {
                    if (!lieux) return false
                    if (typeof allreadyGeoLoc[lieux] == 'undefined') {
                      var coordLatLng = getGPSfromVillesINSEE(data[i][INSEE_key]);
                      if (typeof coordLatLng !== 'undefined') {
                        allreadyGeoLoc[lieux] = {};
                        allreadyGeoLoc[lieux].lat = coordLatLng.lat;
                        allreadyGeoLoc[lieux].lng = coordLatLng.lng;
                        allreadyGeoLoc[lieux].INSEEname = coordLatLng.INSEEname;
                        allreadyGeoLoc[lieux].INSEEzip = coordLatLng.INSEEzip;
                        allreadyGeoLoc[lieux].INSEEcode = coordLatLng.INSEEcode;
                        allreadyGeoLoc[lieux].INSEEdept = coordLatLng.INSEEdept;
                      };
                    };
                  };
                };
              };
              return allreadyGeoLoc;

              function getGPSfromVillesINSEE(locData) {
                for (var i = 0; i < villesINSEE.length; i++) {
                  var zip = villesINSEE[i]["zip_code"];
                  var insee = villesINSEE[i]["insee_code"];
                  var name = villesINSEE[i]["name"].toUpperCase();
                  /*if (locData == 987 && (zip == null || insee == null)) {
                    console.log(locData)
                  }*/
                  var isMatched = false;
                  var department = parseInt(villesINSEE[i]["department_code"]);
                  if (zip == null || insee == null) {
                    if (department == locData) isMatched = true;
                  }
                  else {
                    var zipInt = parseInt(zip);
                    var inseeInt = parseInt(insee);
                    if (zipInt == locData || inseeInt == locData || insee == locData) isMatched = true;
                  }
                  if (isMatched) {
                    //var nameLoc = locData.COMMUNE.toUpperCase();
                    //var splitedLocName = nameLoc.split(" ");
                    //var debName = splitedLocName[0];
                    //if (name.indexOf(debName) > -1) {
                    var coordLatLng = {};
                    coordLatLng.lat = villesINSEE[i]["gps_lat"];
                    coordLatLng.lng = villesINSEE[i]["gps_lng"];
                    coordLatLng.INSEEname = villesINSEE[i]["name"];
                    coordLatLng.INSEEzip = villesINSEE[i]["zip_code"];
                    coordLatLng.INSEEcode = villesINSEE[i]["insee_code"];
                    coordLatLng.INSEEdept = villesINSEE[i]["department_code"];
                    return coordLatLng;
                    //}
                  }
                }
                return;
              }
            }

            add2Layer(indexCal);

            function add2Layer(indexLoc) {
              /*var lieux = data[indexLoc].COMMUNE + ',' + data[indexLoc].INSEE;
              if (!isNaN(data[indexLoc].INSEE)) lieux += ', France';*/
              indexCal++;
              if (!isValidCoord(data[indexLoc].lat, data[indexLoc].lng)) {
                var lieux = makeLocation(data, indexLoc);
                if (!lieux) return false
                if ((typeof allreadyGeoLoc[lieux] == 'undefined' || typeof allreadyGeoLoc[lieux].lat == 'undefined' || typeof allreadyGeoLoc[lieux].lng == 'undefined')) {
                  L.esri.Geocoding.geocode({
                      requestParams: {
                        maxLocations: 1
                      }
                    })
                    .text(lieux)
                    .run(function(error, results, response) {
                      var _this = this
                      if (error) {
                        console.log(error);
                        console.log(lieux);
                        return;
                      }
                      //if (!error && typeof results.results !== 'undefined') {
                      if (!error && results.results.length > 0) {
                        indexRes++;
                        data[indexLoc].lat = results.results[0].latlng.lat;
                        data[indexLoc].lng = results.results[0].latlng.lng;
                      }
                      else {
                        data[indexLoc].doc = 'Failed geoloc';
                      }
                      checkIfEnd(indexCal, indexEnd, add2Layer);
                    });
                }
                else {
                  if (typeof allreadyGeoLoc[lieux] !== 'undefined') {
                    data[indexLoc].lat = allreadyGeoLoc[lieux].lat;
                    data[indexLoc].lng = allreadyGeoLoc[lieux].lng;
                    if (typeof allreadyGeoLoc[lieux].INSEEname !== 'undefined') data[indexLoc].INSEEname = allreadyGeoLoc[lieux].INSEEname;
                    if (typeof allreadyGeoLoc[lieux].INSEEzip !== 'undefined') data[indexLoc].INSEEzip = allreadyGeoLoc[lieux].INSEEzip;
                    if (typeof allreadyGeoLoc[lieux].INSEEcode !== 'undefined') data[indexLoc].INSEEcode = allreadyGeoLoc[lieux].INSEEcode;
                    if (typeof allreadyGeoLoc[lieux].INSEEdept !== 'undefined') data[indexLoc].INSEEdept = allreadyGeoLoc[lieux].INSEEdept;
                  }
                  checkIfEnd(indexCal, indexEnd, add2Layer);
                }
              }
              else checkIfEnd(indexCal, indexEnd, add2Layer);

            };

          }
          /*).catch(function() {
            console.log('Oh no, epic failure!');
          }*/
        );
      }

      function checkIfEnd(indexCal, indexEnd, add2Layer) {
        if (indexCal < indexEnd) {
          add2Layer(indexCal)
        }
        else if (indexEnd > 0) {
          for (var i = 0; i < data.length; i++) {
            if (typeof data[i].INSEEname !== 'undefined') delete data[i].INSEEname;
            if (typeof data[i].INSEEzip !== 'undefined') delete data[i].INSEEzip;
            if (typeof data[i].INSEEcode !== 'undefined') delete data[i].INSEEcode;
            if (typeof data[i].INSEEdept !== 'undefined') delete data[i].INSEEdept;
          }
          setDeptsAndRegs(data, "builDepts")

          function setDeptsAndRegs(data, option) {
            // Usage:  Load different file types with one callback
            // Copyright (c) 2013 Ryan Clark
            // https://gist.github.com/rclark/5779673
            L.TopoJSON = L.GeoJSON.extend({
              addData: function(jsonData) {
                if (jsonData.type === "Topology") {
                  for (var key in jsonData.objects) {
                    var geojson = topojson.feature(jsonData, jsonData.objects[key]);
                    L.GeoJSON.prototype.addData.call(this, geojson);
                  }
                }
                else {
                  L.GeoJSON.prototype.addData.call(this, jsonData);
                }
              }
            });
            if (option == "builDepts") {
              for (var i = 0; i < data.length; i++) data[i]["département"] = "non défini";
              var topoFile = 'https://philquand.github.io/Javascript/LeafLet/json/deptsFranceData.json';
            }
            else {
              for (var i = 0; i < data.length; i++) data[i]["région"] = "non définie";
              var topoFile = 'https://philquand.github.io/Javascript/LeafLet/json/regsFranceData.json';
            }
            Promise.all([
              // GeoJSON des départements et régions françaises
              // d'après https://france-geojson.gregoiredavid.fr
              load.json(topoFile),
            ]).then(
              function(values) {
                console.log('Everything has been loaded!');

                topoVal = loadVal(values, topoFile);

                var topoLayer = new L.TopoJSON();

                addTopoData(topoVal);

                function addTopoData(topoData) {

                  topoLayer.addData(topoData);
                  //topoLayer.addTo(map);
                  topoLayer.eachLayer(handleLayer);
                }

                function handleLayer(layer) {
                  //var randomValue = Math.random(),

                  var areaBounds = layer.getBounds();
                  var areaCode = layer.feature.properties.code;
                  var areaGeometry = layer.feature.geometry;
                  var areaName = layer.feature.properties.nom;
                  var areaNum = getNumItems();

                  function getNumItems() {
                    var d = 0;
                    for (var idx = 0; idx < data.length; idx++) {
                      if (inside([data[idx].lng, data[idx].lat], areaGeometry)) {
                        if (option == "builDepts") data[idx].département = areaName;
                        else data[idx].région = areaName;
                        d += 1;
                      }
                    }
                    return d;

                    function inside(point, TopoGeom) {
                      var insideVal = false;
                      if (TopoGeom["type"] == "MultiPolygon") {
                        for (var i = 0; i < TopoGeom["coordinates"].length; i++) {
                          var polygon = TopoGeom["coordinates"][i][0];
                          // Le point est-il dans le polygone
                          if (isInsidePolygon(point, polygon)) {
                            insideVal = true;
                            for (var j = 1; j < TopoGeom["coordinates"][i].length; j++) {
                              var polygon = TopoGeom["coordinates"][i][j];
                              // Le point est-il dans l'un des trous du polygone
                              if (isInsidePolygon(point, polygon)) {
                                insideVal = false;
                              }
                            }
                          }
                        }
                      }
                      else {
                        var polygon = TopoGeom["coordinates"][0];
                        // Le point est-il dans le polygone
                        if (isInsidePolygon(point, polygon)) {
                          insideVal = true;
                          for (var j = 1; j < TopoGeom["coordinates"].length; j++) {
                            var polygon = TopoGeom["coordinates"][j];
                            // Le point est-il dans l'un des trous du polygone
                            if (isInsidePolygon(point, polygon)) {
                              insideVal = false;
                            }
                          }
                        }
                      }

                      return insideVal;
                      // ray-casting algorithm based on
                      // https://github.com/substack/point-in-polygon/blob/master/index.js

                      function isInsidePolygon(point, vs) {
                        var x = point[0],
                          y = point[1];

                        var inside = false;
                        for (var i = 0, j = vs.length - 1; i < vs.length; j = i++) {
                          var xi = vs[i][0],
                            yi = vs[i][1];
                          var xj = vs[j][0],
                            yj = vs[j][1];

                          var intersect = ((yi > y) != (yj > y)) &&
                            (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
                          if (intersect) inside = !inside;
                        }

                        return inside;

                      }
                    }
                  }

                }

                if (option == "builDepts") setDeptsAndRegs(data, "builRegs");
                else {
            /*var iconMarkers = iconMarkersBuilder(data);
            for (var i = 0; i < data.length; i++) {
              var popupContent = $('<div></div>');
              var popupBody = $("<div class='popBody'></div>");
              popupContent.append(popupBody);
              if (typeof options.popupData.title !== 'undefined') {
                var title = options.popupData.title;
                //if (typeof data !== 'undefined' && typeof data[title] !== 'undefined') {
                popupBody.append("<div class='popLieux' style='color:" + data[i].iconMarker.colorFG + "; background-color:" + data[i].iconMarker.colorBG + ";'>" + data[i][title] + "</div>");
                //}
              }
              if (typeof options.popupData.properties !== 'undefined') {
                var properties = options.popupData.properties;
              }
              else {
                var hidden = [];
                if (typeof options.popupData.hidden !== 'undefined') hidden = options.popupData.hidden;
                //hidden = hidden.concat(["lat", "lng", "iconMarker", "LATITUDE", "LONGITUDE"]);
                hidden = hidden.concat(["lat", "lng", "iconMarker"]);
                if (typeof options.popupData.title !== 'undefined' && typeof data[popupStruc.title] !== 'undefined') hidden.push([opupStrucData.title])
                var dataKeys = Object.getOwnPropertyNames(indexEvent)
                var properties = [];
                for (var j = 0; j < dataKeys.length; j++) {
                  var keyStatus = true;
                  for (var k = 0; k < hidden.length; k++) {
                    if (dataKeys[j] == hidden[k]) keyStatus = false;
                  }
                  if (keyStatus == true) properties.push(dataKeys[j]);
                }
              }
              for (var j = 0; j < properties.length; j++) {
                var item = properties[j];
                if (data[i][item] != '') popupBody.append("<div class='popItem'><span class='popTitle'>" + item + "</span><br>" + data[i][item] + "</div>");
              }
              var content = JSON.stringify(popupContent.html());
              data[i].doc = content;
              }*/
                runData(data, true);
                }

              }
            )
            /*.catch(function() {
                            console.log('Oh no, epic failure!');
                          });*/
          };


          /*function dataPopUp(data) {
            var iconMarkers = iconMarkersBuilder(data);
            for (var i = 0; i < data.length; i++) {
              var popupContent = $('<div></div>');
              var popupBody = $('<div class="popBody"></div>');
              popupContent.append(popupBody);
              if (typeof options.popupData.title !== 'undefined') {
                var title = options.popupData.title;
                //if (typeof data !== 'undefined' && typeof data[title] !== 'undefined') {
                popupBody.append('<div class="popLieux" style="color:' + data[i].iconMarker.colorFG + '; background-color:' + data[i].iconMarker.colorBG + ';">' + data[i][title] + '</div>');
                //}
              }
              if (typeof options.popupData.properties !== 'undefined') {
                var properties = options.popupData.properties;
              }
              else {
                var hidden = [];
                if (typeof options.popupData.hidden !== 'undefined') hidden = options.popupData.hidden;
                //hidden = hidden.concat(["lat", "lng", "iconMarker", "LATITUDE", "LONGITUDE"]);
                hidden = hidden.concat(["lat", "lng", "iconMarker"]);
                if (typeof options.popupData.title !== 'undefined' && typeof data[popupStruc.title] !== 'undefined') hidden.push([opupStrucData.title])
                var dataKeys = Object.getOwnPropertyNames(indexEvent)
                var properties = [];
                for (var j = 0; j < dataKeys.length; j++) {
                  var keyStatus = true;
                  for (var k = 0; k < hidden.length; k++) {
                    if (dataKeys[j] == hidden[k]) keyStatus = false;
                  }
                  if (keyStatus == true) properties.push(dataKeys[j]);
                }
              }
              for (var j = 0; j < properties.length; j++) {
                var item = properties[j];
                if (data[i][item] != '') popupBody.append('<div class="popItem"><span class="popTitle">' + item + '</span><br>' + data[i][item] + '</div>');
              }
              data[i].doc = popupContent.html();
            };
          //if (asyncCompTableData) {
          //  for (var i = 0; i < indexEvent.length; i++) {
          //    indexEvent[i]["département"] = "non défini";
          //    indexEvent[i]["région"] = "non définie";
          // };
          //}
          }*/
        }
      };
    };

    function runData(indexEvent, isToSaveData) {
      // À conserver pour exporter des données...
      /*exportData(indexEvent)
      //return;
      function exportData(indexEvent) {
        var expCOMMUNE = indexEvent[0].COMMUNE;
          if(indexEvent[0].INSEEcode == null) var expINSEE = indexEvent[0].INSEEdept;
          else var expINSEE = indexEvent[0].INSEEcode;
        for (i = 1; i < indexEvent.length; i++) {
          expCOMMUNE += ',' + indexEvent[i].INSEEname;
          if(indexEvent[i].INSEEcode == null) expINSEE += ',' + indexEvent[i].INSEEdept;
          else expINSEE += ',' + indexEvent[i].INSEEcode;
        }
        $('#exportCOMMUNE').html(expCOMMUNE);
        $('#exportINSEE').html(expINSEE);
        for (i = 1; i < indexEvent.length; i++) {
          delete indexEvent[i].INSEEname;
          delete indexEvent[i].INSEEzip;
          delete indexEvent[i].INSEEcode;
          delete indexEvent[i].INSEEdept;
        }      
        $('#dataStore').html(JSON.stringify(indexEvent));
        console.log('achieved');
        loading.find('p').html('Les données de type COMMUNE et INSEE ont été exportées avec succés');
      }*/
      if (isToSaveData) {
        if ($('#dataStore').length == 0) {
          var dataStore = $('<div id="dataStore" style="display:none"></div>')
          $('#infoMap-wrapper').prepend(dataStore)
        }
        else var dataStore = $('#dataStore');

        var valGeoJSON = getGeoJSONFromData(indexEvent);
        for (i = 0; i < valGeoJSON["features"].length; i++) {
          //delete valGeoJSON["features"][i]["properties"]["iconMarker"];
          delete valGeoJSON["features"][i]["properties"]["marker"];
          for (var prop in valGeoJSON["features"][i]["properties"]) {
            if (valGeoJSON["features"][i]["properties"][prop] == null) {
              delete valGeoJSON["features"][i]["properties"][prop];
            }

          }
          //delete valGeoJSON["features"][i]["properties"]["doc"];
        };
        dataStore.html(JSON.stringify(valGeoJSON));

        if ($('#optStore').length == 0) {
          var optStore = $('<div id="optStore" style="display:none"></div>')
          $('#infoMap-wrapper').prepend(optStore)
        }
        else var optStore = $('#optStore');
        var optStoreSTR = stringifyJSO2V(options, 'options');
        optStore.html(optStoreSTR);

        function getGeoJSONFromData(indexEvent) {
          var valGeoJSON = {};
          valGeoJSON["type"] = "FeatureCollection";
          valGeoJSON["features"] = [];
          for (var i = 0; i < indexEvent.length; i++) {
            var newItem = {
              "type": "Feature",
              "geometry": {
                "type": "Point"
              }
            };
            newItem["geometry"]["coordinates"] = [indexEvent[i]["lng"], indexEvent[i]["lat"]];
            newItem["properties"] = clone(indexEvent[i]);
            delete newItem["properties"].lng;
            delete newItem["properties"].lat;
            valGeoJSON["features"].push(newItem);
          }
          return valGeoJSON;
        };
      };
      console.log('achieved');
      
      loading.css('display', 'none');
      var map_invalidateSize = runMap(indexEvent);

      function runMap(indexEvent) {

        var stateChangingButton ;
        var iconMarkers = iconMarkersBuilder(indexEvent);
        var iconMarkersLength = iconMarkers.length;
        var map, onSetDefaultMapView, refreshIndexEvent;

        /*function removeAreaMarkers() {
          for (var i = 0; i < indexEvent.length; i++) {
            markers.removeLayer(indexEvent[i].marker);
          }
        }*/
        function setDefaultMapView() {

          //map.setView(new L.LatLng(47, 2), 6);
          
          map.fitBounds([
            [51.10, 2.47],
            [48.37, -5.16],
            [42.38, -1.85],
            [42.47, 3.16],
            [43.80, 7.96],
            [49.03, 8.08],
          ]);
          if (typeof onSetDefaultMapView !== 'undefined') onSetDefaultMapView();
        }

        function setMapView() {
          return;
        }

        function dataPopUp(data) {
          var popupContent = $('<div></div>');
          var popupBody = $('<div class="popBody"></div>');
          popupContent.append(popupBody);
          if (typeof options.popupData.title !== 'undefined') {
            var title = options.popupData.title;
            if (typeof data !== 'undefined' && typeof data[title] !== 'undefined') {
              popupBody.append('<div class="popLieux" style="color:' + data.iconMarker.colorFG +'; background-color:' + data.iconMarker.colorBG +';">' + data[title] + '</div>');
            }
          }
          if (typeof options.popupData.properties !== 'undefined') {
            var properties = options.popupData.properties;
          }
          else {
            var hidden = [];
            if (typeof options.popupData.hidden !== 'undefined') hidden = options.popupData.hidden;
            //hidden = hidden.concat(["lat", "lng", "iconMarker", "LATITUDE", "LONGITUDE"]);
            hidden = hidden.concat(["lat", "lng", "iconMarker"]);
            //if (typeof options.popupData.title !== 'undefined' && typeof data[popupStruc.title] !== 'undefined') hidden.push([opupStrucData.title])
            var dataKeys = Object.getOwnPropertyNames(data)
            var properties = [];
            for (var i = 0; i < dataKeys.length; i++) {
              var keyStatus = true;
              for (var j = 0; j < hidden.length; j++) {
                if (dataKeys[i] == hidden[j]) keyStatus = false;
              }
              if (keyStatus == true) properties.push(dataKeys[i]);
            }
          }
          for (var i = 0; i < properties.length; i++) {
              var item = properties[i];
              if (typeof data[item] !== 'undefined' && data[item] != '') popupBody.append('<div class="popItem"><span class="popTitle">' + item + '</span><br>' + data[item] + '</div>');
            }
          return popupContent.html();
        }
        var markers = L.markerClusterGroup({
          maxClusterRadius: 5
        });
        for (i = 0; i < indexEvent.length; i++) {
          indexEvent[i].iconMarker = iconMarkers[indexEvent[i].iconMarker];
          indexEvent[i].doc = dataPopUp(indexEvent[i]);
          //indexEvent[i].doc = JSON.parse(indexEvent[i].doc);
          indexEvent[i].marker = makePopUp(indexEvent[i], setMapView);
        }

        map = initMap('infoMap', indexEvent);
        markers.addTo(map);
        endMarkerBuild(indexEvent);

        function makePopUp(input, setCallBack) {

          if (typeof input.iconMarker === 'undefined' || typeof input.iconMarker.icon === 'undefined' || input.iconMarker.icon == '') {
            var marker = L.marker([input.lat, input.lng]);
          }
          else {
            if (typeof input.lat === 'undefined' || typeof input.lng === 'undefined') {
              console.log('error in makePopUp');
            }
            var marker = L.marker([input.lat, input.lng], {
              icon: input.iconMarker.icon.leaflet
            });
          }
          marker.bindPopup(input.doc, {
            maxWidth: 400,
            minWidth: 250,
            maxHeight: 300,
            className: 'popupCustom',
            autoPan: true,
            closeButton: true,
            autoPanPadding: [5, 5]
          });
          marker.getPopup().on('remove', function() {
            setCallBack();
          });
          return marker;
        }

        function initMap(idMap, indexEvent) {

          'use strict'

          map = loadMap(idMap);

          //zoomRemove(map);
          map.options.minZoom = 5;
          //map.options.maxZoom = 8;
          map.options.maxZoom = 12;
          map.scrollWheelZoom.disable();

          setDefaultMapView();

          var baseMaps = {
            'par défaut': L.tileLayer('')
          };
          baseMaps['par défaut'].addTo(map);
          var legendMaps = {}

          // Constructeur du contrôle de carte LeafLet
          addControlLayer();          
          function addControlLayer() {
            // Constructeur du contrôle de carte LeafLet
            if (typeof options.controlLayers === 'undefined' ){
              var legendAllMarkers = addLegend()
            } else if (typeof options.controlLayers.controlMaps === 'undefined' || options.controlLayers.controlMaps.on != true) {
              // Ajout de la seule carte de fond
              var option = {
                baseMaps: null,
                legend: legendMaps,
                map: map,
              };
              buildBaseMaps(option);
            }
            else {
              // Ajout du contrôle
              loadMapPicture({
                typMap: "builDepts",
                baseMaps: baseMaps,
                legend: legendMaps,
                data: indexEvent,
                map: map,
                callback: builDeptsCallback
                //callback: buildBaseMaps
              });
            }

            function builDeptsCallback(option) {
              loadMapPicture({
                typMap: "builRegs",
                baseMaps: baseMaps,
                legend: legendMaps,
                data: indexEvent,
                map: map,
                callback: buildBaseMaps
              });
            }

            function buildBaseMaps(option) {
              var controlBasemapsAndOverlays = new L.control.layers(option["baseMaps"], objectOverlays["controlOverlays"]).addTo(option["map"]);
              for (var i = 0; i < objectOverlays["overlays"].length; i++) {
                objectOverlays["controlOverlays"][objectOverlays["overlays"][i].title].addTo(map);
              }

              var controlBasemapsAndOverlaysHTML = $(controlBasemapsAndOverlays.getContainer());
              var controlMapsDiv = controlBasemapsAndOverlaysHTML.find(".leaflet-control-layers-base").first();
              if (option["baseMaps"] !== null) controlMapsDiv.prepend('<div class="legendTitle" style="display:block; text-align:center;">carte</div>')
              var controlOverlaysDiv = controlBasemapsAndOverlaysHTML.find(".leaflet-control-layers-overlays").first();
              if (objectOverlays["overlayTitle"] != '') {
                controlOverlaysDiv.prepend('<div class="legendTitle" style="display:block; text-align:center;">' + objectOverlays["overlayTitle"] + '</div>')
              };
              if (objectOverlays["overlays"].length == 1) {
                controlBasemapsAndOverlaysHTML.find(".leaflet-control-layers-separator").css("display", "none");
                controlBasemapsAndOverlaysHTML.find(".leaflet-control-layers-overlays").css("display", "none");
              };
              var baselayerName = 'par défaut';
              var legendAllMarkers = addLegend()
              map.on('baselayerchange', function(eventLayer) {
                baselayerName = eventLayer.name;
                map.removeControl(legendAllMarkers);
                map.removeControl(option["legend"]["départements"]);
                map.removeControl(option["legend"]["régions"]);
                setDefaultMapView();
                if (baselayerName == 'par défaut') {
                  //map.addControl(legendAllMarkers);
                  refreshIndexEvent = [];
                  for (i = 0; i < indexEvent.length; i++) {
                    refreshIndexEvent.push(i)
                  }
                  var iconNum = refreshMarkers(refreshIndexEvent);
                  //map.removeControl(legendAllMarkers);
                  legendAllMarkers = addLegend(iconNum)
                  map.addControl(legendAllMarkers);
                  stateChangingButton.enable();
                }
                else {
                  map.addControl(option["legend"][eventLayer.name]);
                  refreshIndexEvent = [];
                  stateChangingButton.disable();
                }
                refreshMarkers(refreshIndexEvent);
              });
              map.on('overlayadd', function(eventLayer) {
                console.log('adding : ' + eventLayer.name)
                if (baselayerName == 'par défaut') {
                  for (var k = 0; k < objectOverlays["overlays"].length; k++) {
                    if (objectOverlays["overlays"][k].title == eventLayer.name) {
                      objectOverlays["overlays"][k].isVisible = true;
                    };
                  };
                  var iconNum = refreshMarkers(refreshIndexEvent);
                  map.removeControl(legendAllMarkers);
                  legendAllMarkers = addLegend(iconNum)
                  map.addControl(legendAllMarkers);
                };
              });
              map.on('overlayremove', function(eventLayer) {
                console.log('removing : ' + eventLayer.name)
                if (baselayerName == 'par défaut') {
                  for (var k = 0; k < objectOverlays["overlays"].length; k++) {
                    if (objectOverlays["overlays"][k].title == eventLayer.name) {
                      objectOverlays["overlays"][k].isVisible = false;
                    };
                  };
                  var iconNum = refreshMarkers(refreshIndexEvent);
                  map.removeControl(legendAllMarkers);
                  legendAllMarkers = addLegend(iconNum)
                  map.addControl(legendAllMarkers);
                };
              });

              /*function updateLegend() {
                var iconNum = refreshMarkers(refreshIndexEvent);
                map.removeControl(legendAllMarkers);
                legendAllMarkers = addLegend(iconNum)
                map.addControl(legendAllMarkers);
              }*/
            };
            
          };

          function addLegend(iconNum) {
            if (typeof iconNum === 'undefined') {
              iconNum = [];
              for (i = 0; i < indexEvent.length; i++) {
                iconNum.push(true)
              }
            }
            for (var k = 0; k < iconMarkersLength; k++) {
              iconMarkers[k].nbMapEvents = 0;
            }
            for (var i = 0; i < indexEvent.length; i++) {
              if (iconNum[i]) {
                for (var k = 0; k < iconMarkersLength; k++) {
                  if (indexEvent[i].iconMarker.title == iconMarkers[k].title) {
                    iconMarkers[k].nbMapEvents++;
                  }
                }
              }
            }
            var legendAllMarkers = L.control({
              position: 'topright'
            });

            legendAllMarkers.onAdd = function(map) {
              var divlegendAllMarkers = L.DomUtil.create('div', 'info legend');
              divlegendAllMarkers.innerHTML = '';
              if (legendTitle != '') divlegendAllMarkers.innerHTML += '<span class="legendTitle" style="display:block; text-align:center;">' + legendTitle + '</span>';
              for (var k = 0; k < iconMarkersLength; k++) {
                if (typeof iconMarkers[k].title !== 'undefined' && iconMarkers[k].nbMapEvents > 0) {
                  if (typeof iconMarkers[k].icon.leaflet === 'undefined') {
                    divlegendAllMarkers.innerHTML += '<img src="https://unpkg.com/leaflet@1.4.0/dist/images/marker-icon-2x.png"> ' + iconMarkers[k].nbMapEvents + ' ' + iconMarkers[k].title + '<br>'
                  }
                  else {
                    var iconVal = iconMarkers[k].icon.leaflet;
                    divlegendAllMarkers.innerHTML += '<img src="' + iconMarkers[k].icon.leaflet.options.iconUrl + '"> ' + iconMarkers[k].nbMapEvents + ' ' + iconMarkers[k].title + '<br>'
                  }
                }
              }
              return divlegendAllMarkers;
            };

            legendAllMarkers.addTo(map);
            return legendAllMarkers;
          }

          if(typeof options.banner !== 'undefined') bannerCoord();
          function bannerCoord() {
            bannerCoord = L.control({
              //position: 'topright'
              position: 'bottomleft'
            });

            bannerCoord.onAdd = function(map) {
              var divBannerCoord = L.DomUtil.create('div', 'bannerCoord');
              divBannerCoord.innerHTML = options.banner;
              return divBannerCoord;
            };

            bannerCoord.addTo(map);
          }

          refreshMarkers();
          function refreshMarkers(refreshIndexEvent) {
            for (var i = 0; i < indexEvent.length; i++) {
              markers.removeLayer(indexEvent[i].marker);
            }
            if (typeof refreshIndexEvent === 'undefined') {
              refreshIndexEvent = [];
              for (i = 0; i < indexEvent.length; i++) {
                refreshIndexEvent.push(i)
              }
            }
            var iconNum = [];
            for (var i = 0; i < refreshIndexEvent.length; i++) {
              iconNum.push(false);
              for (var k = 0; k < objectOverlays["overlays"].length; k++) {
                if (objectOverlays["overlays"][k].isVisible && objectOverlays["overlays"][k].isInGroup(indexEvent[refreshIndexEvent[i]])) {
                  iconNum[i] = true;
                }
              }
              if (iconNum[i]) {
                markers.addLayer(indexEvent[refreshIndexEvent[i]].marker);
              }
              else {
                markers.removeLayer(indexEvent[refreshIndexEvent[i]].marker);
              }
            }
            return iconNum;
          }

          function loadMapPicture(option) {
            switch (option["typMap"]) {
              case "builDepts":
                loadClustering(option, option["data"]);
                break;
              case "builRegs":
                loadClustering(option, option["data"]);
                break;
              default:
                option["baseMaps"]['par défaut'] = L.tileLayer('');
            };
            function loadClustering(option) {
              // Constructeur de la carte TopoJSON avec pays pour LeafLet
              // ajout de l'échelle des couleurs pour les cartes TopoJSON
              if (option["typMap"] == "builDepts") {
                if (typeof options.controlLayers === 'undefined' || typeof options.controlLayers.controlMaps === 'undefined' || typeof options.controlLayers.controlMaps.gradeDepts === 'undefined')
                  var grades = [0, 1, 3, 5, 7, 10, 15, 20];
                else
                  var grades = options.controlLayers.controlMaps.gradeDepts;
                //var colorDeb = '#D5E3FF';
                //var colorFin = '#003171';
                var colorDeb = '#FFFF00';
                var colorFin = '#FF0000';
                var colorStyle = '#555';
              }
              else {
                if (typeof options.controlLayers === 'undefined' || typeof options.controlLayers.controlMaps === 'undefined' || typeof options.controlLayers.controlMaps.gradeRegs === 'undefined')
                  var grades = [0, 20, 30, 40, 55, 60, 80, 100];
                else
                  var grades = options.controlLayers.controlMaps.gradeRegs;
                //var colorDeb = '#D5E3FF';
                //var colorFin = '#003171';
                var colorDeb = '#FFFF00';
                var colorFin = '#FF0000';
                var colorStyle = '#555';
              }
              // ajout des couche départements et régions colorées TopoJSON
              loadMapTopoJSON(option);

              function loadMapTopoJSON(option) {
                // Usage:  Load different file types with one callback
                // Copyright (c) 2013 Ryan Clark
                // https://gist.github.com/rclark/5779673
                L.TopoJSON = L.GeoJSON.extend({
                  addData: function(jsonData) {
                    if (jsonData.type === "Topology") {
                      for (var key in jsonData.objects) {
                        var geojson = topojson.feature(jsonData, jsonData.objects[key]);
                        L.GeoJSON.prototype.addData.call(this, geojson);
                      }
                    }
                    else {
                      L.GeoJSON.prototype.addData.call(this, jsonData);
                    }
                  }
                });
                if (option["typMap"] == "builDepts") {
                  var topoFile = 'https://philquand.github.io/Javascript/LeafLet/json/deptsFranceData.json';
                }
                else {
                  var topoFile = 'https://philquand.github.io/Javascript/LeafLet/json/regsFranceData.json';
                }
                Promise.all([
                  // ressources utilisées pour construire la carte TopoSJON
                  load.js('https://philquand.github.io/Javascript/LeafLet/chroma.min.js'),
                  load.js('https://d3js.org/topojson.v1.min.js'),
                  // GeoJSON des départements et régions françaises
                  // d'après https://france-geojson.gregoiredavid.fr
                  load.json(topoFile),
                ]).then(
                  function(values) {
                    console.log('Everything has been loaded!');

                    var topoVal = loadVal(values, topoFile);

                    var topoLayer = new L.TopoJSON();
                    var colorScale = chroma
                      //.scale(['#D5E3FF', '#003171'])
                      .scale([colorDeb, colorFin])
                      .domain([0, 1]);

                    var enterPopup = 0;

                    var areaNumItems = {};
                    if (option["typMap"] == "builDepts") {
                       for (var idx = 0; idx < option["data"].length; idx++) {
                        if (typeof option["data"][idx]["département"] !== 'undefined') {
                          if (typeof areaNumItems[option["data"][idx]["département"]] === 'undefined') {
                            areaNumItems[option["data"][idx]["département"]] = [];
                          }
                          areaNumItems[option["data"][idx]["département"]].push(idx);
                        }
                      }
                      var areaType = "département"
                      var baseMapsName = "départements";
                    }
                    else {
                       for (var idx = 0; idx < option["data"].length; idx++) {
                        if (typeof option["data"][idx]["région"] !== 'undefined') {
                          if (typeof areaNumItems[option["data"][idx]["région"]] === 'undefined') {
                            areaNumItems[option["data"][idx]["région"]] = [];
                          }
                          areaNumItems[option["data"][idx]["région"]].push(idx);
                        }
                      }
                      var areaType = "région"
                      var baseMapsName = "régions";
                    }
                    addTopoData(topoVal);
                                        

                    function addTopoData(topoData) {

                      topoLayer.addData(topoData);
                      //topoLayer.addTo(map);
                      topoLayer.eachLayer(handleLayer);

                      option["legend"][baseMapsName] = L.control({
                        position: 'topright'
                      });
                      option["legend"][baseMapsName].onAdd = function(map) {

                        var div = L.DomUtil.create('div', 'info legend'), labels = [];

                        // loop through our density intervals and generate a label with a colored square for each interval
                        for (var i = grades.length - 1; i >= 0; i--) {
                          //for (var i = 0; i < grades.length; i++) {
                          var legColor = thisColor(grades[i] + 1)
                          div.innerHTML +=
                            '<i style="background:' + legColor + '"></i><span>' +
                            grades[i] + (grades[i + 1] ? '&ndash;' + grades[i + 1] + '</span><br>' : '+</span><br>');
                        }

                        return div;
                      };

                    }

                    function thisColor(d) {
                      var nbMax = grades.length;
                      for (var i = nbMax - 1; i >= 0; i--) {
                        if (d > grades[i]) {
                          var retColor = colorScale(i / nbMax).hex();
                          return retColor;
                        }
                      }
                      return 'white';
                    }


                    function handleLayer(layer) {
                      //var randomValue = Math.random(),

                      var areaBounds = layer.getBounds();
                      var areaCode = layer.feature.properties.code;
                      var areaGeometry = layer.feature.geometry;
                      var areaName = layer.feature.properties.nom;
                      var inMarkers = [];
                      var areaNum = getNumItems();
                      var areaEnterCode, areaBindPopup;

                      // Create an element to hold all your text and markup
                      var container = $('<div />');

                      // Delegate all event handling for the container itself and its contents to the container
                      container.on('click', '.smallPolygonLink', function() {
                        enterPopup = areaName;
                        var myevent = layer["_events"];
                        var myclick = layer["_events"]["click"][0];
                        myclick["fn"]();
                        //layer.unbindPopup();
                      });

                      // Insert whatever you want into the container, using whichever approach you prefer
                      //container.html(dataPopUp);
                      var areaDataPopUp = container[0];

                      var fillColor = thisColor(areaNum);
                      layer.setStyle({
                        fillColor: fillColor,
                        //fillColor: getColor,
                        fillOpacity: 1,
                        color: colorStyle,
                        weight: 1,
                        opacity: .5
                      });

                      if ("ontouchstart" in document.documentElement) {
                        layer.on({
                          click: touchLayer,
                        });
                      }
                      else {
                        layer.on({
                          click: clickLayer,
                          //mouseover: enterLayer,
                          //mouseout: leaveLayer,
                        });
                      }

                      map.on('overlayadd', function(eventLayer) {
                        addingOverlay(eventLayer);
                      });
                      map.on('overlayremove', function(eventLayer) {
                        removingOverlay(eventLayer);
                      });

                      function addingOverlay(eventLayer) {
                        console.log('in loadMapTopoJSON adding : ' + eventLayer.name);
                        for (var k = 0; k < objectOverlays["overlays"].length; k++) {
                          if (objectOverlays["overlays"][k].title == eventLayer.name) {
                            objectOverlays["overlays"][k].isVisible = true;
                          };
                        };
                        areaNum = getAreaNum(inMarkers);
                        fillColor = thisColor(areaNum);
                        layer.setStyle({
                          fillColor: fillColor,
                        });
                        container.html(dataPopUp);
                        if (layer.options.fillOpacity == 0) refreshMarkers(refreshIndexEvent);
                      }

                      function removingOverlay(eventLayer) {
                        console.log('in loadMapTopoJSON removing : ' + eventLayer.name);
                        for (var k = 0; k < objectOverlays["overlays"].length; k++) {
                          if (objectOverlays["overlays"][k].title == eventLayer.name) {
                            objectOverlays["overlays"][k].isVisible = false;
                          };
                        };
                        areaNum = getAreaNum(inMarkers);
                        fillColor = thisColor(areaNum);
                        layer.setStyle({
                          fillColor: fillColor,
                        });
                        container.html(dataPopUp);
                        if (layer.options.fillOpacity == 0) refreshMarkers(refreshIndexEvent);
                      }

                      function getAreaNum(refreshIndexEvent) {
                        var getAreaNumReturn = 0;
                        if (typeof refreshIndexEvent === 'undefined') {
                          refreshIndexEvent = [];
                          for (i = 0; i < indexEvent.length; i++) {
                            refreshIndexEvent.push(i)
                          }
                        }
                        for (var i = 0; i < refreshIndexEvent.length; i++) {
                          var isInMarkers = false;
                          for (var k = 0; k < objectOverlays["overlays"].length; k++) {
                            if (objectOverlays["overlays"][k].isVisible && objectOverlays["overlays"][k].isInGroup(indexEvent[refreshIndexEvent[i]])) {
                              isInMarkers = true;
                            }
                          }
                          if (isInMarkers) {
                            getAreaNumReturn++;
                          }
                        }
                        return getAreaNumReturn;
                      }

                      function dataPopUp() {
                        var popupContent = $("<div></div>");
                        var popupBody = $("<div class='popBody'></div>");
                        popupContent.append(popupBody);
                        popupBody.append("<div class='popLieux' style='background-color:" + thisColor(areaNum) + "'>" + areaName + "</div>");
                        switch (areaNum) {
                          case 0:
                            popupBody.append("<div class='popItem'><span class='popTitle'>Aucun &#232;tablissement concern&#232;</span><br></div>");
                            break;
                          case 1:
                            popupBody.append("<div class='popItem'><span class='popTitle'>Un &#232;tablissement concern&#232;</span><br><span class='popNote'><a href='#' class='smallPolygonLink'>clickez pour plus de détails</a></span></div>");
                            break;
                          default:
                            popupBody.append("<div class='popItem'><span class='popTitle'>Nombre d&#39;&#232;tablissements concern&#232;s</span><br><span class='popNum'>" + areaNum + "</span><br><span class='popNote'><a href='#' class='smallPolygonLink'>clickez pour plus de détails</a></span></div>");
                        };
                        return popupContent.html();
                      }

                      function getNumItems() {
                        if (typeof areaNumItems !== 'undefined') {
                          if (typeof areaNumItems[areaName] !== 'undefined') {
                            for (var idx = 0; idx < areaNumItems[areaName].length; idx++) {
                                inMarkers.push(areaNumItems[areaName][idx]);
                            }
                            return areaNumItems[areaName].length;
                          }
                          else return 0;
                        }
                        else {
                          var d = 0;
                          for (var idx = 0; idx < option["data"].length; idx++) {
                            if (inside([option["data"][idx].lng, option["data"][idx].lat], areaGeometry)) {
                              inMarkers.push(idx);
                              d += 1;
                            }
                          }
                          return d;
                        }

                        function inside(point, TopoGeom) {
                          var insideVal = false;
                          if (TopoGeom["type"] == "MultiPolygon") {
                            for (var i = 0; i < TopoGeom["coordinates"].length; i++) {
                              var polygon = TopoGeom["coordinates"][i][0];
                              // Le point est-il dans le polygone
                              if (isInsidePolygon(point, polygon)) {
                                insideVal = true;
                                for (var j = 1; j < TopoGeom["coordinates"][i].length; j++) {
                                  var polygon = TopoGeom["coordinates"][i][j];
                                  // Le point est-il dans l'un des trous du polygone
                                  if (isInsidePolygon(point, polygon)) {
                                    insideVal = false;
                                  }
                                }
                              }
                            }
                          }
                          else {
                            var polygon = TopoGeom["coordinates"][0];
                            // Le point est-il dans le polygone
                            if (isInsidePolygon(point, polygon)) {
                              insideVal = true;
                              for (var j = 1; j < TopoGeom["coordinates"].length; j++) {
                                var polygon = TopoGeom["coordinates"][j];
                                // Le point est-il dans l'un des trous du polygone
                                if (isInsidePolygon(point, polygon)) {
                                  insideVal = false;
                                }
                              }
                            }
                          }

                          return insideVal;
                          // ray-casting algorithm based on
                          // https://github.com/substack/point-in-polygon/blob/master/index.js

                          function isInsidePolygon(point, vs) {
                            var x = point[0],
                              y = point[1];

                            var inside = false;
                            for (var i = 0, j = vs.length - 1; i < vs.length; j = i++) {
                              var xi = vs[i][0],
                                yi = vs[i][1];
                              var xj = vs[j][0],
                                yj = vs[j][1];

                              var intersect = ((yi > y) != (yj > y)) &&
                                (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
                              if (intersect) inside = !inside;
                            }

                            return inside;

                          }
                        }
                      }

                      function touchLayer() {

                        //clickLayer()
                        this.bindPopup(areaPopup, {
                          setLatLng: areaBounds.getCenter(),
                          sticky: true,
                          maxHeight: 160,
                          maxWidth: 400,
                          minWidth: 250
                        }).openPopup();
                        this.getPopup().on('remove', function() {});
                      }

                      //function enterLayer() {}

                      function clickLayer() {
                        if (typeof onSetDefaultMapView !== 'undefined') onSetDefaultMapView();
                        if (enterPopup != areaName) {
                          // Insert whatever you want into the container, using whichever approach you prefer
                          this.bindPopup(areaDataPopUp).openPopup();
                          var areaPopup = this.getPopup();
                          areaPopup.setLatLng(areaBounds.getCenter());
                          return;
                        }
                        map.closePopup();
                        refreshIndexEvent = inMarkers;
                        refreshMarkers(refreshIndexEvent);
                        layer.setStyle({
                          fillOpacity: 0
                        });
                        areaBindPopup = this['unbindPopup'];
                        if (typeof areaBindPopup !== 'undefined') {
                          this.unbindPopup();
                        }
                        enterPopup = 0;
                        option["map"].fitBounds(areaBounds, {
                          padding: [100, 100]
                        });
                        var _this = layer;
                        onSetDefaultMapView = function() {
                          //_this.getPopup().remove();
                          _this.setStyle({
                            fillOpacity: 1
                          });
                          //removeAreaMarkers();
                          refreshMarkers([]);
                        }
                      }

                      //function leaveLayer() {);
                    }

                    option["baseMaps"][baseMapsName] = topoLayer;
                    if (typeof option["callback"] == 'undefined') {
                      if (option["typMap"] == "builDepts") {
                        if (typeof option["map"] !== 'undefined') option["baseMaps"]['départements'].addTo(option["map"]);
                      }
                      else {
                        if (typeof option["map"] !== 'undefined') option["baseMaps"]['régions'].addTo(option["map"]);
                      }
                    }
                    else option["callback"](option);

                  }
                )
                /*.catch(function() {
                                console.log('Oh no, epic failure!');
                              });*/
              };
            };
          };

          var searchControl = L.esri.Geocoding.geosearch().addTo(map);

          var results = L.layerGroup().addTo(map);

          var redIcon = new L.Icon({
            iconUrl: 'https://cdn.rawgit.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-red.png',
            shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',
            iconSize: [13, 20],
            iconAnchor: [6, 20],
            popupAnchor: [1, -17],
            shadowSize: [20, 20]
          });
          searchControl.on('results', function(data) {
            results.clearLayers();
            for (var i = data.results.length - 1; i >= 0; i--) {
              results.addLayer(L.marker(data.results[i].latlng, {
                icon: redIcon
              }));
            }
          });

          return map;
          // Constructeur de la carte LeafLet
          function loadMap(idMap) {
            L.map(idMap).remove();
            var map = L.map(idMap);
            switch (options.fondCarte) {
              case 'IGN':
                loadIGN();

                function loadIGN() {
                  Promise.all([
                    // Début ressources utilisées pour construire la carte IGN
                    load.js('https://ignf.github.io/geoportal-extensions/leaflet-latest/dist/GpPluginLeaflet.js'),
                    load.css('https://ignf.github.io/geoportal-extensions/leaflet-latest/dist/GpPluginLeaflet.css'),
                    load.js('https://ignf.github.io/geoportal-extensions/leaflet-latest/dist/GpPluginLeaflet-src.js'),
                    load.css('https://ignf.github.io/geoportal-extensions/leaflet-latest/dist/GpPluginLeaflet-src.css'),
                    // Fin ressources utilisées pour construire la carte IGN

                  ]).then(
                    function() {
                      console.log('Everything has loaded!');

                      // accés au Geoportail
                      Gp.Services.getConfig({
                        // clé d'accès aux ressources gratuites de l'IGN récupérée sur le compte fiddle de l'IGN"
                        apiKey: "f5cse26aiqvu6j4xqtngh5zh",
                        // clé d'accès aux ressources gratuites de l'IGN sécurisée par referer "https://philquand.github.io/"
                        //apiKey: "85iagcmek80ofvkhz7komcga",
                        onSuccess: go
                      });

                      function go() {
                        var layer = L.geoportalLayer.WMTS({
                          layer: "GEOGRAPHICALGRIDSYSTEMS.PLANIGNV2"
                        });
                        layer.addTo(map);
                      }
                    }).catch(function() {
                    console.log('Oh no, epic failure!');
                  });

                };
                break;
              case 'mapbox':
                loadMapbox();

                function loadMapbox() {
                  // Usage:  Load different file types with one callback
                  Promise.all([
                    // Début ressources utilisées pour construire la carte MapBox
                    load.js('https://api.mapbox.com/mapbox-gl-js/v2.0.1/mapbox-gl.js'),
                    load.css('https://api.mapbox.com/mapbox-gl-js/v2.0.1/mapbox-gl.css'),
                    load.js('https://unpkg.com/mapbox-gl-leaflet/leaflet-mapbox-gl.js'),
                    // Fin ressources utilisées pour construire la carte mondiale colorée MapBox

                  ]).then(
                    function() {
                      console.log('Everything has loaded!');

                      var mapboxAccessToken = 'pk.eyJ1IjoicGhpbHF1YW5kIiwiYSI6ImNraTRyZ2d0ZTBzamEycXN5dzcybW00OHQifQ.wAs5l5LUQbq7lcSBNwHOLA';

                      /*
                      // Downsample tiles for faster load times on slow internet connections by
                      // adjusting the format property in styleLayer. See
                      // https://docs.mapbox.com/api/maps/#static-tiles for all format options.
                      L.mapbox.styleLayer('mapbox://styles/mapbox/streets-v11', {
                        tileLayer: {
                          format: 'jpg70'
                        }
                      }).addTo(map);
                      */
                      var layer = L.mapboxGL({
                        accessToken: mapboxAccessToken,
                        // get your own MapTiler token at https://cloud.maptiler.com/ or use MapBox style
                        //style: 'https://api.maptiler.com/maps/basic/style.json?key=gbetYLSD5vR8MdtZ88AQ'
                        style: 'mapbox://styles/mapbox/streets-v11',
                      });
                      layer.addTo(map);
                    }).catch(function() {
                    console.log('Oh no, epic failure!');
                  });
                };
                break;
              default:
                var layer = new L.tileLayer('http://{s}.tile.osm.org/{z}/{x}/{y}.png', {
                  attribution: '&copy; <a href="https://osm.org/copyright">OpenStreetMap</a> contributors'
                })
                layer.addTo(map);
            }

            map.addControl(new L.Control.Fullscreen({
              title: {
                'false': 'Voir en plein écran',
                'true': 'Quitter le plein écran'
              }
            }));

            // `fullscreenchange` Event that's fired when entering or exiting fullscreen.
            map.on('fullscreenchange', function() {
              if (map.isFullscreen()) {
                map.setZoom(7);
              }
              else {
                setDefaultMapView();
              }
            });
            
            map.createPane('labels');

            // This pane is above markers but below popups
            map.getPane('labels').style.zIndex = 650;

            // Layers in this pane are non-interactive and do not obscure mouse/touch events
            map.getPane('labels').style.pointerEvents = 'none';


            return map;

          };

          function zoomRemove(map) {
            //remove zoom functions
            map.removeControl(map.zoomControl);
            map.touchZoom.disable();
            map.doubleClickZoom.disable();
            map.scrollWheelZoom.disable();
            map.boxZoom.disable();
            map.keyboard.disable();
          }

        }

        function endMarkerBuild(indexEvent) {
          /*for (i = 0; i < indexEvent.length; i++) {
            for (k = 0; k < iconMarkersLength; k++) {
              if (indexEvent[i].iconMarker.class == iconMarkers[k].class) {
                iconMarkers[k].nbMapEvents++;
              }
            }
            marker = makePopUp(indexEvent[i], setCallBack);
            markers.addLayer(marker);
          }*/

          Promise.all([
            //  chargements des dépendances css
            load.css('https://cdn.jsdelivr.net/npm/leaflet-easybutton@2/src/easy-button.css'),
            load.css('https://use.fontawesome.com/releases/v5.0.6/css/all.css'),
            //  chargements des dépendances js
            load.js('https://cdn.jsdelivr.net/npm/leaflet-easybutton@2/src/easy-button.js'),
            //load.js('https://philquand.github.io/Javascript/LeafLet/leaflet-button/L.Control.Button.js'),
          ]).then(
            function() {
              console.log('Everything has loaded!');

              var defaultViewButton = L.easyButton({
                states: [{
                  stateName: 'default-view', // name the state
                  icon: 'fa-home', // and define its properties
                  title: 'vue par défaut', // like its title
                  onClick: function(btn, map) { // and its callback
                    setDefaultMapView();
                  }
                }]
              });
              defaultViewButton.addTo(map);

              checkautresDepts(map, indexEvent);

              function checkautresDepts(map, indexEvent) {
                var autresDepts = [{
                    name: 'Corse',
                    bounds: L.latLngBounds([
                      [43.07, 8.39],
                      [41.29, 9.74]
                    ]),
                    hasevents: false
                  },
                  {
                    name: 'Martinique',
                    bounds: L.latLngBounds([
                      [14.905, -61.500],
                      [14.377, -60.762]
                    ]),
                    hasevents: false
                  },
                  {
                    name: 'Guadeloupe',
                    bounds: L.latLngBounds([
                      [16.5572, -61.971],
                      [15.7881, -60.946]
                    ]),
                    hasevents: false
                  },
                  {
                    name: 'Guyane',
                    bounds: L.latLngBounds([
                      [6.16, -55.08],
                      [1.88, -51.16]
                    ]),
                    hasevents: false
                  },
                  {
                    name: 'LaRéunion',
                    bounds: L.latLngBounds([
                      [-19.6496, 54.5825],
                      [-21.6107, 58.1036]
                    ]),
                    hasevents: false
                  },
                  {
                    name: 'Hexagone',
                    bounds: L.latLngBounds([
                      [51.10, 2.47],
                      [48.37, -5.16],
                      [43.38, -1.85],
                      [42.47, 3.16],
                      [43.80, 7.96],
                      [49.03, 8.08],
                      [49.03, 8.08]
                    ]),
                    hasevents: false
                  }
                ];
                autresDepts = checkautresDeptsBounds(autresDepts, indexEvent);
                var states = [];
                for (var i = 0; i < autresDepts.length; i++) {
                  if (!autresDepts[i].hasevents) continue
                  var localState = {};
                  localState.stateName = autresDepts[i].name; // name the state
                  j = i;
                  do {
                    j = j + 1;
                    if (j == autresDepts.length) j = 0;
                  }
                  while (!autresDepts[j].hasevents);
                  localState.nextStateName = autresDepts[j].name; // name of the next state
                  localState.icon = 'fa-plane'; // and define its properties
                  switch (autresDepts[i].name) {
                    case 'Corse':
                      localState.title = 'vol vers la Corse'; // like its title
                      localState.onClick = function(btn, map) { // and its callback
                        map.flyTo({
                          lat: 42.19,
                          lng: 9.08
                        }, 6);
                        for (var j = 0; j < btn.options.states.length; j++) {
                          if (btn._currentState.stateName == btn.options.states[j].stateName) {
                            btn.state(btn.options.states[j].nextStateName); // change state on click!
                            break;
                          }
                        }
                      };
                      break;
                    case 'Martinique':
                      localState.title = 'vol vers la Martinique'; // like its title
                      localState.onClick = function(btn, map) { // and its callback
                        map.flyTo({
                          lat: 14.7297,
                          lng: -60.9655
                        }, 6);
                        for (var j = 0; j < btn.options.states.length; j++) {
                          if (btn._currentState.stateName == btn.options.states[j].stateName) {
                            btn.state(btn.options.states[j].nextStateName); // change state on click!
                            break;
                          }
                        }
                      };
                      break;
                    case 'Guadeloupe':
                      localState.title = 'vol vers la Guadeloupe'; // like its title
                      localState.onClick = function(btn, map) { // and its callback
                        map.flyTo({
                          lat: 16.228,
                          lng: -61.526
                        }, 6);
                        for (var j = 0; j < btn.options.states.length; j++) {
                          if (btn._currentState.stateName == btn.options.states[j].stateName) {
                            btn.state(btn.options.states[j].nextStateName); // change state on click!
                            break;
                          }
                        }
                      };
                      break;
                    case 'Guyane':
                      localState.title = 'vol vers la Guyane'; // like its title
                      localState.onClick = function(btn, map) { // and its callback
                        map.flyTo({
                          lat: 3.945,
                          lng: -53.13
                        }, 6);
                        for (var j = 0; j < btn.options.states.length; j++) {
                          if (btn._currentState.stateName == btn.options.states[j].stateName) {
                            btn.state(btn.options.states[j].nextStateName); // change state on click!
                            break;
                          }
                        }
                      };
                      break;
                    case 'LaRéunion':
                      localState.title = 'vol vers la Réunion'; // like its title
                      localState.onClick = function(btn, map) { // and its callback
                        map.flyTo({
                          lat: -20.887,
                          lng: 55.455
                        }, 6);
                        for (var j = 0; j < btn.options.states.length; j++) {
                          if (btn._currentState.stateName == btn.options.states[j].stateName) {
                            btn.state(btn.options.states[j].nextStateName); // change state on click!
                            break;
                          }
                        }
                      };
                      break;
                    default:
                      localState.title = "retour vers l'Hexagone"; // like its title
                      localState.bounds = autresDepts[i].bounds;
                      localState.onClick = function(btn, map) { // and its callback
                        for (var j = 0; j < btn.options.states.length; j++) {
                          if (btn._currentState.stateName == btn.options.states[j].stateName) {
                            btn.state(btn.options.states[j].nextStateName); // change state on click!
                            map.flyToBounds(btn.options.states[j].bounds);
                            break;
                          }
                        }
                      };
                  }
                  states.push(localState);
                }
                if (states.length > 1) {
                  stateChangingButton = L.easyButton({
                    states: states
                    /*[{
                            stateName: 'zoom-to-forest',        // name the state
                            icon:      'fa-plane',               // and define its properties
                            title:     'zoom to a forest',      // like its title
                            onClick: function(btn, map) {       // and its callback
                                map.setView([46.25,-121.8],10);
                                btn.state('zoom-to-school');    // change state on click!
                            }
                        }, {
                            stateName: 'zoom-to-school',
                            icon:      'fa-paper-plane',
                            title:     'zoom to a school',
                            onClick: function(btn, map) {
                                map.setView([42.3748204,-71.1161913],16);
                                btn.state('zoom-to-forest');
                            }
                    }]*/
                  });

                  stateChangingButton.addTo(map);
                }

                function checkautresDeptsBounds(autresDepts, indexEvent) {
                  for (i = 0; i < indexEvent.length; i++) {
                    for (k = 0; k < autresDepts.length; k++) {
                      if (autresDepts[k].bounds.contains(indexEvent[i])) {
                        autresDepts[k].hasevents = true;
                      }
                    }
                  }
                  return autresDepts;
                };

              };


            }
          ).catch(function() {
            console.log('Oh no, epic failure!');
          });
        };

        var map_invalidateSize = function() {
          map.invalidateSize();
        }
        $('.leaflet-control-zoom').wrap('<div class="topLeftControls"></div>');
        $('.geocoder-control.leaflet-control').appendTo($('.topLeftControls'));
        return map_invalidateSize
      }

      var runTableAndButton = function() {
        if (typeof options.popupData.properties !== 'undefined' || typeof options.tableData !== 'undefined') {
          var btData = $('<button type="button" class="styled" id="btData"></button>')
          $("#infoMap-wrapper").prepend(btData);
          btData.click(function(e) {
            if ($('#btData').html() == 'Carte') {
              btDataCarte(map_invalidateSize);
            }
            else {
              btDataTable();
            }
          });
          btDataCarte(map_invalidateSize);

          function btDataTable() {
            $('#btData').html('Carte');
            //$('#infoMap-wrapper > :not(#btData)').css('display', 'none')
            $('#infoMap-wrapper > #infoMap').css('display', 'none')
            $('#table_wrapper').css('display', 'block')
            //$('#table').css('display', 'block')
          }

          function btDataCarte(map_invalidateSize) {
            $('#btData').html('Données');
            //$('#infoMap-wrapper > :not(#btData)').css('display', 'block')
            $('#infoMap-wrapper > #infoMap').css('display', 'block')
            map_invalidateSize();
            $('#table_wrapper').css('display', 'none')
            //$('#table').css('display', 'none')
          }
          runTable(indexEvent);
        }
      };
      runTableAndButton();
      function runTable(data) {

        var tableColums = [];
        if (jQuery.type(options.tableData) !== 'undefined' && jQuery.type(options.tableData.properties) !== 'undefined') {
          var columns = [];
          var properties = options.tableData.properties;
          for (var i = 0; i < properties.length; i++) {
            if (jQuery.type(properties[i]['name']) === 'string') {
              columns.push({
                data: properties[i]['name'],
                title: properties[i]['name'],
                defaultContent: '',
                //selectable: false
              });
              if (jQuery.type(properties[i]['filter']) !== 'undefined') {
                var item = {};
                if (properties[i]['filter'] == 'selection') {
                  item['column_number'] = i;
                  item['filter_default_label'] = "Sélectionnez";
                  item['filter_match_mode'] = "exact";
                }
                else if (jQuery.isNumeric(properties[i]['filter']) && jQuery.isArray(options.tableData['filters']) && (properties[i]['filter'] < options.tableData['filters'].length)) {
                  if (jQuery.isFunction(options.tableData['filters'][properties[i]['filter']]['func']) && jQuery.isArray(options.tableData['filters'][properties[i]['filter']]['data'])) {
                    item['column_number'] = i;
                    item['filter_type'] = 'custom_func';
                    item['custom_func'] = options.tableData['filters'][properties[i]['filter']]['func'];
                    item['data'] = options.tableData['filters'][properties[i]['filter']]['data'];
                  }
                }
                if (jQuery.type(item) !== 'undefined') {
                item['defaultContent'] = '';
                tableColums.push(item);
                }
              };
            }
          };
        }
        else {
          var item = options.popupData.title;
          if (typeof item === 'undefined') {
            var columns = [];
          }
          else {
            var columns = [{
              data: item,
              title: item,
              defaultContent: '',
              //selectable: true
            }];
          }
          for (i = 0; i < options.popupData.properties.length; i++) {
            var item = options.popupData.properties[i];
            columns.push({
              data: item,
              title: item,
              defaultContent: '',
              //selectable: false
            });
          }
        }
        var initComplete = function() {
          //New datatable API (capital "D")
          var myTable = $(this).DataTable();
          yadcf.init(myTable, tableColums)
        }
        $('#table').DataTable({
          data: indexEvent,
          "language": {
            "url": "//cdn.datatables.net/plug-ins/1.10.22/i18n/French.json"
          },
          columns: columns,
          initComplete: initComplete,
        });
      };
    };
  }
};
})(jQuery);
(function($) {

  //var checkIfStoreNeedsUpdate = true;

  // spécial pour le site de la CN
  $('.widget_text.so-panel.widget.widget_custom_html h3:contains(Ressources externes)').css('display', 'none');
  $('.widget_text.so-panel.widget.widget_custom_html h3:contains(Données Lettre)').css('display', 'none');
  $('.widget_text.so-panel.widget.widget_custom_html h3:contains(Images + infos semaine + pdf)').css('display', 'none');
  $('.widget_text.so-panel.widget.widget_custom_html h3:contains(Ressources internes)').css('display', 'none');
  // fin spécial pour le site de la CN


  optionsTESTInnerFormedData = {
    data: {
      //base: 'https://docs.google.com/spreadsheets/d/1XBQe8JiZ5cepr-s_TBjBqQcaBx4Y83SQS4PaNoXnNjM/edit?usp=sharing',
      //base: 'https://philquand.github.io/Javascript/Blog-widgets/Collectif Santé 37/FermeturesHopitaux/export_Services_publics.geojson',
      //base: 'https://philquand.github.io/Javascript/Blog-widgets/Collectif Santé 37/FermeturesHopitaux/Applications/AnalyseCN/export_Tous_les_etablissements_concernes_Fromgml3.geojson',
      //base: 'https://philquand.github.io/Javascript/Blog-widgets/Collectif Santé 37/FermeturesHopitaux/Applications/AnalyseCN/export_Tous_les_etablissements_concernes_Fromgml3.geojson',
      //base: 'https://philquand.github.io/Javascript/Blog-widgets/Collectif Santé 37/FermeturesHopitaux/Applications/AnalyseCN/export_Tous_les_etablissements_concernes-2021-06-23-depts.geojson',
      //base:'https://philquand.github.io/Javascript/Blog-widgets/Collectif%20Sant%C3%A9%2037/FermeturesHopitaux/Applications/AnalyseCN/export_ght_2021_12_03.geojson',
      base:'https://philquand.github.io/Javascript/Blog-widgets/Collectif%20Sant%C3%A9%2037/FermeturesHopitaux/Applications/AnalyseCN/export_tous_etabl_2021_12_03_WDR.geojson',

      geolocData: function geolocData(iData, iVar) {
        /*if (typeof iData[iVar].LATITUDE !== 'undefined') {
          if(iData[iVar].LATITUDE != '') iData[iVar].lat = iData[iVar].LATITUDE;
          delete iData[iVar].LATITUDE;
        }
        if (typeof iData[iVar].LONGITUDE !== 'undefined') {
          if(iData[iVar].LONGITUDE != '') iData[iVar].lng = iData[iVar].LONGITUDE;
          delete iData[iVar].LONGITUDE;
        }
        if (isValidCoord(iData[iVar].lat, iData[iVar].lng)) return;*/
        var lieux = iData[iVar].nom_commune + ',' + iData[iVar].INSEE_COM;
        if (!isNaN(iData[iVar])) lieux += ', France';
        return lieux;
      },
      //INSEE_KEY: "INSEE_COM",
      dataTransformer: true,
      /*dataTransformer: function(inputData, setCallBack) {
      var outputData = 'https://philquand.github.io/Javascript/Blog-widgets/Collectif Santé 37/FermeturesHopitaux/Applications/AnalyseCN/export_Tous_les_établissements_concernés-2021_02_23.js';
      loadFromJS(outputData,
        (procData) => {
         procData = window["data"];
         if (typeof procData !== 'undefined') {
           var outputData = []
           for (var j = 0; j < procData["features"].length; j++) {
             outputData.push(j);
           }
           for (var i = 0; i < inputData.length; i++) {
             const inputDataId = inputData[i]["id"];
             for (var j = 0; j < outputData.length; j++) {
               if (inputDataId == procData["features"][outputData[j]]["properties"]["id"]) {
                 inputData[i]["lng"] = procData["features"][outputData[j]]["geometry"]["coordinates"][0]
                 inputData[i]["lat"] = procData["features"][outputData[j]]["geometry"]["coordinates"][1]
                 outputData.splice(j, 1)
                 break;
               }
             }
           };
           setCallBack(inputData);
         }
         else console.log('error in dataTransformer...');
        },
        (err) => {
          console.log(err.message);
          //loading.html(err.message);
        }
      );
      }*/
    },
    //fondCarte : 'IGN',
    popupData : {
      title: 'LIEUX',
      //properties: ["LIEUX", "SUPPRESSIONS", "MENACES", "victoire"],
      hidden: ['id', 'LIEUX', 'INSEE_COM', 'département', 'région'],
    },
    tableData: {
      properties: [{
        name: 'LIEUX',
        filter: 'selection'
      }, {
        name: 'nom_commune',
        filter: 0
      }, {
        name: 'département',
        filter: 'selection'
      }, {
        name: 'REGION',
        filter: 'selection'
      }, {
        name: 'SUPPRESSIONS',
        filter: 0
       }, {
        name: 'MENACES',
        filter: 'selection'
      }, {
        name: 'CATEGORIE',
        filter: 'selection'
      }, {
        name: 'CODE POSTAL',
        filter: 0
     }],
      filters: [{
        data: [{
          value: 'avec valeur',
          label: 'Avec valeur'
        }, {
          value: 'sans valeur',
          label: 'Sans valeur'
        }],
        func: (filterVal, columnVal) => {
          switch (filterVal) {
            case 'sans valeur':
              if (columnVal === '') {
                return true;
              }
              else return false;
              break;
            default:
              if (columnVal !== '') {
                return true;
              }
              else return false;
              break;
          }
        }
      }]
    },
    controlLayers: {
      controlMaps: {on: true},
      controlOverlays: {
        title: 'Établissements avec',
        overlays: [{
            title: 'suppressions',
            isInGroup: data => {
              return isOKString(data['SUPPRESSIONS']);
            }
          },
          {
            title: 'menaces',
            isInGroup: function(data) {
              return isOKString(data['MENACES']);
            }
          },
          {
            title: 'victoires',
            isInGroup: function(data) {
              return isOKString(data['victoire']);
            }
          },
          {
            title: 'autres',
            isInGroup: data => {
              if (!isOKString(data['SUPPRESSIONS']) && !isOKString(data['MENACES']) && !isOKString(data['victoire'])) {
                return true;
              }
              else return false;
            }
          },
        ]
      }
    },
    legend: {
      title: 'Établissements avec',
      test: function(){},
      affect: function(data) {
        if (isOKString(data['SUPPRESSIONS']) || isOKString(data['MENACES'])) {
          return 0;
        }
        else {
          return 1;
        }
      },
      icons: [{
        icon: {leaflet: new L.Icon({
          iconUrl: 'https://philquand.github.io/Javascript/LeafLet/Leaflet-color-markers/img/marker-icon-2x-violet.png',
          shadowUrl: 'https://philquand.github.io/Javascript/LeafLet/Leaflet-color-markers/img/marker-shadow.png',
          iconSize: [13, 20],
          iconAnchor: [6, 20],
          popupAnchor: [1, -17],
          shadowSize: [20, 20]
        })},
        title: 'suppressions ou menaces',
        colorBG: '#9A26CA',
        colorFG: '#F8F8F8',
      }, {
        icon: {leaflet: new L.Icon({
          iconUrl: 'https://philquand.github.io/Javascript/LeafLet/Leaflet-color-markers/img/marker-icon-2x-blue.png',
          shadowUrl: 'https://philquand.github.io/Javascript/LeafLet/Leaflet-color-markers/img/marker-shadow.png',
          iconSize: [13, 20],
          iconAnchor: [6, 20],
          popupAnchor: [1, -17],
          shadowSize: [20, 20]
        })},
        title: 'autres',
        colorBG: '#2781CA',
        colorFG: '#FFFFFF',
      }]
    },
    banner: '<img border="0" data-original-height="200" data-original-width="600" src="https://4.bp.blogspot.com/-WgwJsMGzYPE/WkoKfP1TJDI/AAAAAAAAAG0/7vLne-Wtd3cjxFK4Qm-NOJPFBeWShhlKwCLcBGAs/s400/AE8A2A5A-3BDA-4D84-82D5-B34D7215D364.png"/>',
  };  
  $('#Fermetures').mapAllBlogs(optionsTESTInnerFormedData);

})(jQuery);
</script>
<style>
div.dataTables_wrapper div.dataTables_length {
   margin-left: 1em;
}
div.dataTables_wrapper div.dataTables_length select {
    width: 100%;
}
*, *:after, *:before {
  box-sizing: border-box;
}

body {
  font-family: Verdana, Arial, sans-serif;
  /*font-size: 12px;*/
}

.table-striped {
  border-spacing: 0;
  border-collapse: collapse;
  text-align: center;
  padding-bottom: 25px;
}

td, th, hr {
  border-bottom: 1px solid #ddd;
}

th {
  cursor: pointer;
}

th:hover {
  background-color: #f7f7f7;
}

tfoot {
  display: table-header-group;
}

input {
  font-size: 16px;
  margin-right: 1.5em;
}

input, td, th {
  padding: 10px;
  /*vertical-align: bottom;*/
}
/*à vérifier pour les images*/
.table-striped td img {
  width: 100px;
  padding: 5px;
  vertical-align: bottom;
}

div.dataTables_wrapper .table-striped thead th {
  background:#E42421;
  color:white;
}
div.dataTables_wrapper .table-striped th {
  max-width: 200px !important;
}
div.dataTables_wrapper .table-striped th select{
  max-width: 100% !important;
}
div.dataTables_wrapper .table-striped tbody tr:nth-of-type(even) {
  background-color: rgba(228, 36, 33, 0.04);
}
div.dataTables_wrapper .table-striped tbody tr:nth-of-type(odd) {
  background:#FFFFFF;
}
div.dataTables_wrapper .table-striped tbody tr:hover {
  background:#BDC3C7;
  color:#FFFFFF;
}
div.dataTables_wrapper .table-striped select {
  background:white;
}
.easy-button-button {
   padding:  0 0 0 0;
	 margin-top: 0;
}
.easy-button-button .fa-home, .easy-button-button .fa-plane {
   color: black;
}
.leaflet-control-zoom.leaflet-bar.leaflet-control a:link, .leaflet-control-zoom.leaflet-bar.leaflet-control a:visited {
	 color: black;		
}
.bannerCoord img {
    width: 25vw;
    max-width: 150px;
}
.legend {
    padding:.5em .75em;
    color: #555;
    background:white;
}
.legend span {
  position: relative;
  bottom: 3px;
}
.legend i {
    width: 18px;
    height: 18px;
    float: left;
    margin-right: 8px;
    /*margin-right: 1em;*/
    opacity: 0.7;
}
.legendTitle {
  font-style: italic;
  font-weight: bold;
}

.leaflet-container.default-cursor-enabled {
    cursor: default;
}
.topLeftControls {
    display: flex; 
    align-items: flex-start;
    width: 100%; 
}
/*.topLeftControls > * {
    flex: 1 100%;
    margin-left: auto; 
    margin-right: auto;
}*/
#infoMap-wrapper {
    padding: 0 0 0 0;
    margin: 0 auto;
    width: 800px;
    max-width: 90%;
}
#infoMap {
    width: 100%;
    height: 675px;
    /*max-height: 70vh;*/
    overflow: hidden;
}
#table_wrapper thead tr th {
    vertical-align: top;
}
#table_wrapper thead tr th .yadcf-filter-wrapper {
    display: flex;
    flex-direction: row;
    align-items: center;
    justify-content: center;
    width: 100%;
}
@media (max-width: 550px) {
    #infoMap {
      height: 550px;
    }
    .bannerCoord img {
      display: none;
    }
}
</style>